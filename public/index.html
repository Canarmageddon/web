<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<meta name="theme-color" content="#000000"/>
		<meta name="description" content="Web site created using create-react-app"/>
		<link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png"/>
		<link
		href='https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css' rel='stylesheet'/>

		<!--
												      manifest.json provides metadata used when your web app is installed on a
												      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
												    -->
		<link
		rel="manifest" href="%PUBLIC_URL%/manifest.json"/>
		<!--
												      Notice the use of %PUBLIC_URL% in the tags above.
												      It will be replaced with the URL of the `public` folder during the build.
												      Only files inside the `public` folder can be referenced from the HTML.
												
												      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
												      work correctly both with client-side routing and a non-root public URL.
												      Learn how to configure a non-root public URL by running `npm run build`.
												    -->
		<title>Canardmageddon</title>
		<script></script>
		<!-- Import Mapbox GL JS -->
		<script src="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js"></script>
		<link
		href="https://api.tiles.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" rel="stylesheet"/>

		<!-- Import Mapbox GL Directions -->
		<script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.2/mapbox-gl-directions.js"></script>
		<link
		rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-directions/v4.0.2/mapbox-gl-directions.css" type="text/css"/>

		<!-- Import Turf & Polyline -->
		<script src="https://npmcdn.com/@turf/turf/turf.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/mapbox-polyline/1.1.1/polyline.js"></script>
	</head>
	<body>
		<noscript>You need to enable JavaScript to run this app.</noscript>
		<div id="root"></div>
		<!--
												      This HTML file is a template.
												      If you open it directly in the browser, you will see an empty page.
												
												      You can add webfonts, meta tags, or analytics to this file.
												      The build step will place the bundled scripts into the <body> tag.
												
												      To begin the development, run `npm start` or `yarn start`.
												      To create a production bundle, use `npm run build` or `yarn build`.
												    -->
	</body>
</html>
<style>
	#map {
		width: 100%;
		height: 100vh;
	}
</style>

<script>
	mapboxgl.accessToken = "pk.eyJ1IjoiYXNsbmRza3ZucWRvZm1uIiwiYSI6ImNreWJyN3VkZzBpNnUydm4wcnJ5MmdvYm0ifQ.YNwpI3-HgF6nMhdaRRkKBg";
let map;
let lstMarker = [];
let lstDestination = [];

function clear() {
map.setLayoutProperty("theRoute", "visibility", "none");
map.setLayoutProperty("theBox", "visibility", "none");
}
const lngLatToString = (lngLat) => {
const a = lngLat[0] + "," + lngLat[1]
console.log(a);
return a;
};

const searchPlace = async (location) => {
const resLocation = await fetch(`https://api.mapbox.com/geocoding/v5/mapbox.places/${
encodeURI(location)
}.json?access_token=${
mapboxgl.accessToken
}`).then(res => res.json())
console.log(resLocation)
map.flyTo({center: resLocation.features[0].center, zoom: 13})
lstDestination = [
... lstDestination,
resLocation.features[0]
]
generateRoute()
}
const removePlace=async(i)=>{
  lstDestination.splice(i,1)
  console.log(lstDestination)
  generateRoute()
}
const generateRoute = async () => {
if (lstDestination.length < 2) {
map.setLayoutProperty("theRoute", "visibility", "none");
return;
}
let points = "";
for (let i = 0; i < lstDestination.length; i++) {
points += lngLatToString(lstDestination[i].center) + ";"
}
points = points.slice(0, -1)
console.log(points)
let route = await fetch(`https://api.mapbox.com/directions/v5/mapbox/driving/${points}.json?geometries=polyline&steps=true&overview=full&language=en&access_token=pk.eyJ1IjoiYXNsbmRza3ZucWRvZm1uIiwiYSI6ImNreWJyN3VkZzBpNnUydm4wcnJ5MmdvYm0ifQ.YNwpI3-HgF6nMhdaRRkKBg`).then((res) => res.json());
route = route.routes[0];
// Make each route visible
map.setLayoutProperty("theRoute", "visibility", "visible");
map.setLayoutProperty("theBox", "visibility", "visible");
// Get GeoJSON LineString feature of route
const routeLine = polyline.toGeoJSON(route.geometry);

// Create a bounding box around this route
// The app will find a random point in the new bbox
bbox = turf.bbox(routeLine);
polygon = turf.bboxPolygon(bbox);

// Update the data for the route
// This will update the route line on the map
map.getSource("theRoute").setData(routeLine);

// Update the box
map.getSource("theBox").setData(polygon);

const clear = turf.booleanDisjoint(obstacle, routeLine);

if (clear === true) {
collision = "does not intersect any obstacles!";
detail = `takes ${
(route.duration / 60).toFixed(0)
} minutes and avoids`;
emoji = "✔️";
map.setPaintProperty("theRoute", "line-color", "#74c476");
// Hide the box
map.setLayoutProperty("theBox", "visibility", "none");
// Reset the counter
counter = 0;
} else { // Collision occurred, so increment the counter
counter = counter + 1;
// As the attempts increase, expand the search area
// by a factor of the attempt count
polygon = turf.transformScale(polygon, counter * 0.01);
bbox = turf.bbox(polygon);
collision = "is bad.";
detail = `takes ${
(route.duration / 60).toFixed(0)
} minutes and hits`;
emoji = "⚠️";
map.setPaintProperty("theRoute", "line-color", "#de2d26");

// Add a randomly selected waypoint to get a new route from the Directions API
const randomWaypoint = turf.randomPoint(1, {bbox: bbox});
directions.setWaypoint(0, randomWaypoint["features"][0].geometry.coordinates);
}
};

function createMap() {
map = new mapboxgl.Map({
container: "map", // Specify the container ID
style: "mapbox://styles/mapbox/streets-v11", // Specify which map style to use

center: [
7.72583, 48.46972
], // Specify the starting position [lng, lat]
zoom: 1, // Specify the starting zoom
});


let i = 0;
map.on("click", function (e) {
const coordinates = e.lngLat;
const marker = new mapboxgl.Marker().setLngLat(coordinates).setDraggable(true);
lstMarker = [
... lstMarker,
marker
];
/* new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML("you clicked here: <br/>" + coordinates)
        .addTo(map); */
marker.getElement().addEventListener("click", (e) => {
marker.remove();
lstMarker = lstMarker.filter((i) => i != marker)

// Without it, the click event on map if fired afterward
e.stopPropagation();
});
marker.addTo(map);
});

map.on("load", () => {
map.setLayoutProperty('country-label', 'text-field', ['get', 'name_fr']);
map.setLayoutProperty('state-label', 'text-field', ['get', 'name_fr']);
map.setLayoutProperty('settlement-label', 'text-field', ['get', 'name_fr']);
map.setLayoutProperty('settlement-subdivision-label', 'text-field', ['get', 'name_fr']);
map.addSource("theRoute", {
type: "geojson",
data: {
type: "Feature"
}
});

map.addLayer({
id: "theRoute",
type: "line",
source: "theRoute",
layout: {
"line-join": "round",
"line-cap": "round"
},
paint: {
"line-color": "#cccccc",
"line-opacity": 0.5,
"line-width": 13,
"line-blur": 0.5
}
});


// Source and layer for the bounding box
map.addSource("theBox", {
type: "geojson",
data: {
type: "Feature"
}
});
map.addLayer({
id: "theBox",
type: "fill",
source: "theBox",
layout: {},
paint: {
"fill-color": "#FFC300",
"fill-opacity": 0.5,
"fill-outline-color": "#FFC300"
}
});
});

}


const clearances = {
type: "FeatureCollection",
features: [
{
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.47426, 38.06673]
},
properties: {
clearance: "13' 2"
}
},
{
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.47208, 38.06694]
},
properties: {
clearance: "13' 7"
}
},
{
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.60485, 38.12184]
},
properties: {
clearance: "13' 7"
}
},
{
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.61905, 37.87504]
},
properties: {
clearance: "12' 0"
}
}, {
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.55946, 38.30213]
},
properties: {
clearance: "13' 6"
}
}, {
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.27235, 38.04954]
},
properties: {
clearance: "13' 6"
}
}, {
type: "Feature",
geometry: {
type: "Point",
coordinates: [-84.27264, 37.82917]
},
properties: {
clearance: "11' 6"
}
},
]

};

const obstacle = turf.buffer(clearances, 0.25, {units: "kilometers"});
let bbox = [0, 0, 0, 0];
let polygon = turf.bboxPolygon(bbox);


let counter = 0;
const maxAttempts = 50;
let emoji = "";
let collision = "";
let detail = "";
const reports = document.getElementById("reports");

/*     function addCard(id, element, clear, detail) {
      const card = document.createElement("div");
      card.className = "card";
      // Add the response to the individual report created above
      const heading = document.createElement("div");
      // Set the class type based on clear value
      heading.className =
        clear === true ? "card-header route-found" : "card-header obstacle-found";
      heading.innerHTML =
        id === 0
          ? `${emoji} The route ${collision}`
          : `${emoji} Route ${id} ${collision}`;

      const details = document.createElement("div");
      details.className = "card-details";
      details.innerHTML = `This ${detail} obstacles.`;

      card.appendChild(heading);
      card.appendChild(details);
      element.insertBefore(card, element.firstChild);
    } */

/*     function noRoutes(element) {
      const card = document.createElement("div");
      card.className = "card";
      // Add the response to the individual report created above
      const heading = document.createElement("div");
      heading.className = "card-header no-route";
      emoji = "🛑";
      heading.innerHTML = `${emoji} Ending search.`;

      // Add details to the individual report
      const details = document.createElement("div");
      details.className = "card-details";
      details.innerHTML = `No clear route found in ${counter} tries.`;

      card.appendChild(heading);
      card.appendChild(details);
      element.insertBefore(card, element.firstChild);
    } */

/*     directions.on("clear", () => {
      map.setLayoutProperty("theRoute", "visibility", "none");
      map.setLayoutProperty("theBox", "visibility", "none");

      counter = 0;
      reports.innerHTML = "";
    }); */

/*   directions.on("route", (event) => {
      // Hide the route and box by setting the opacity to zero
      map.setLayoutProperty("theRoute", "visibility", "none");
      map.setLayoutProperty("theBox", "visibility", "none");

      if (counter >= maxAttempts) {
        noRoutes(reports);
      } else {
        // Make each route visible
        for (const route of event.route) {
          // Make each route visible
          map.setLayoutProperty("theRoute", "visibility", "visible");
          map.setLayoutProperty("theBox", "visibility", "visible");

          // Get GeoJSON LineString feature of route
          const routeLine = polyline.toGeoJSON(route.geometry);

          // Create a bounding box around this route
          // The app will find a random point in the new bbox
          bbox = turf.bbox(routeLine);
          polygon = turf.bboxPolygon(bbox);

          // Update the data for the route
          // This will update the route line on the map
          map.getSource("theRoute").setData(routeLine);

          // Update the box
          map.getSource("theBox").setData(polygon);

          const clear = turf.booleanDisjoint(obstacle, routeLine);

          if (clear === true) {
            collision = "does not intersect any obstacles!";
            detail = `takes ${(route.duration / 60).toFixed(0)} minutes and avoids`;
            emoji = "✔️";
            map.setPaintProperty("theRoute", "line-color", "#74c476");
            // Hide the box
            map.setLayoutProperty("theBox", "visibility", "none");
            // Reset the counter
            counter = 0;
          } else {
            // Collision occurred, so increment the counter
            counter = counter + 1;
            // As the attempts increase, expand the search area
            // by a factor of the attempt count
            polygon = turf.transformScale(polygon, counter * 0.01);
            bbox = turf.bbox(polygon);
            collision = "is bad.";
            detail = `takes ${(route.duration / 60).toFixed(0)} minutes and hits`;
            emoji = "⚠️";
            map.setPaintProperty("theRoute", "line-color", "#de2d26");

            // Add a randomly selected waypoint to get a new route from the Directions API
            const randomWaypoint = turf.randomPoint(1, { bbox: bbox });
            directions.setWaypoint(
              0,
              randomWaypoint["features"][0].geometry.coordinates
            );
          }
          // Add a new report section to the sidebar
          addCard(counter, reports, clear, detail);
        }
      }
    });
   */
</script>
